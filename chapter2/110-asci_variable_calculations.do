/* Code for imputing data, cleaning, and calculating indicators, August 2020, modifications by sb Nov 2020, and modifications by bb beginning Dec 2020
 preparation of indicators to be used in index calculation
Tasks: select farms according to minimum number of years of panel participation (and display the loss in terms of observations acc to respective minimum)
       merge data from other sources (n2-median wages, agr, income, price indices, ect.) generated by 020-asci_impadd
       aggregate to NUTS2 level so that n2-data from other sources can be merged
input: stata\dat\\010-asci_fadnDEU_all.dta from 010-asci_fadn.do  fadn data
       020-asci_impadd_medwage_n3.dta               generated by 020-asci_impadd
       020-asci_impadd_fuel_prices.dta              generated by 020-asci_impadd
       020-asci_impadd_ag_income_data.dta           generated by 020-asci_impadd
       020-asci_impadd_producer_price_index.dta     generated by 020-asci_impadd
       020-asci_impadd_cpi.dta                      generated by 020-asci_impadd
output:dat\asci_variables_sb.dta
       log\asci_variables_sb.log    description of variables prepared for asci-computation
*/

clear all
clear matrix
global minyears  3     // minimum number of years of panel participation as condition for inclusion in variable calculations

set linesize 120   // portrait: 100 landscape: 151

global path_raw "C:/asci/stata/raw"  // Brians global raw laptop
global path_dat "C:/asci/stata/dat"  // Brians global dat laptop

*global path_raw "~/Documents/Uni/Projekte/sustainability-index/raw"  // Christophs global raw path
*global path_dat "~/Documents/Uni/Projekte/sustainability-index/dat"  // Christophs global dat path

global path_raw raw  // stephans global raw path
global path_dat dat  // stephans global raw path


capture program drop logfi // drop previous version of this program
program logfi   // produce clean log file (without citing program code): so to make the log file somewhat more an output file

use dat/010-asci_fadnDEU_all.dta, clear 
lab val idn   // detach value label

* DROP ALL RECORDS OF FARMS PARTICIPATING TOO FEW YEARS IN THE PANEL
by id, sort: gen newid = _N     // a constant for each farm indicating the number of years of its panel participation
* check loss in terms of farms and records of dropping farms participating too few years in panel
preserve    // effect on loss of FARMS
duplicates drop idn, force // keep only one observation per farm
collapse (count) N=YEAR (percent) pct=YEAR, by(newid)   // keep only one observation (containing frequencies) per participation level
gen LostIfExclN=sum(N)
gen LostIfExclPct=(LostIfExcl/LostIfExcl[_N])*100
gen RetainedIfExclN = LostIfExclN[_N] - LostIfExclN
gen retIfExclPct = (RetainedIfExclN / LostIfExclN[_N])*100
format *N %7.0fc  
format *ct %7.1fc

*qui log on
di "THE COST IN TERMS OF LOST FARMS WHEN FOCUSING ON FARMS THAT PARTICIPATE IN MANY YEARS:" _n ///
   "Cumulative frequencies and percentages of FARMS (not observations) lost / retained if farms" _n ///
   "with newid number of participation years are excluded" 
list, abbr(20) noobs
di "Interpretation: The cost in terms of lost farms is substantial: We loose 47.9% (retain" _n ///
   "only 52.1%) of farms when excluding all those that participate in 4 years or less. Excluding"  _n ///
   "only those that participate in only 2 or 3 years would mean loosing only 14.9 or 28.4%." _n ///
   "Should we assume farms with short participation to only have lower data quality(due to lesser" _n ///
   "levelling out of idiosyncracies) or are they also less representative???" 
restore

preserve    // effect on loss of OBSERVATIONS
collapse (count) N=YEAR (percent) pct=YEAR, by(newid)   // keep only one observation (containing frequencies) per participation level
gen LostIfExclN=sum(N)
gen LostIfExclPct=(LostIfExcl/LostIfExcl[_N])*100
gen RetainedIfExclN = LostIfExclN[_N] - LostIfExclN
gen retIfExclPct = (RetainedIfExclN / LostIfExclN[_N])*100
format *N %7.0fc  
format *ct %7.1fc

*qui log on
di "The relative loss in terms of Observations is lower than in terms of farms because" _n ///
   "long-term participating farms provide more observations:  We loose 28.7% of OBSERVATIONS" _n ///
   " (but 47.9% of farms) when excluding all FARMS that participate in 4 years or less:"  _n(2) ///
   "Frequencies in terms of sample OBSERVATIONS (not farms)" 
list, abbr(20) noobs
restore
*qui log off 
* END OF: check loss in terms of farms and records of dropping farms participating too few years in panel
drop if newid < $minyears  // uses all years 2004-13, keeps farms with a min of $minyrears observations
drop newid


*** keeping wanted variables
* keep A1 idn G96BV G96CV G96DP TF8 TF14 SYS02 H106E NUTS3 nuts3fv NUTS2 nuts2fv YEAR A32 C01YR C09HR C10HR C11HR F62 F80 SE005 SE011 SE065 SE010 SE015 SE030 SE131 SE132 SE132D SE135 SE195 SE200 SE206 SE256 SE025 SE360 SE420 SE430 SE436 SE441 SE446 SE450 SE455 SE460 SE465 SE470 SE475 SE480 SE485 SE490 SE495 SE136N SE140 SE145 SE165 SE146 SE150 SE155 SE160 SE165 SE170 SE175 SE185 SE206 SE216 SE220 SE225 SE230 SE235 SE240 SE245 SE251 SE256 SE295 SE300 SE336 F81 A40 SE035 SE041 SE042 SE046 SE050 SE054 SE055 SE071 SE072 SE073 SE074 SE075 SE080 SE085 SE090 SE095 SE100 SE105 SE020 SE021 SE016 SE370 SE350 SE623

***** importing and modifying datasets external of fadn

* merging NUTS3 median wage Bundesagentur für Arbeit and generating wage ratio
merge m:m NUTS3 YEAR using dat/020-asci_impadd_medwage_n3.dta 
keep if _merge==3

drop _merge
*browse p_wage NUTS3 year

* merging fuel price data
merge m:m YEAR using dat/020-asci_impadd_fuel_prices.dta
keep if _merge==3
drop _merge

* merging agricultural income data
merge m:1 YEAR using dat/020-asci_impadd_ag_income_data.dta
keep if _merge==3
drop _merge

* merging producer price index data
merge m:m YEAR using dat/020-asci_impadd_producer_price_index.dta
keep if _merge==3
drop _merge

* merging consumer price index data
merge m:m YEAR using dat/020-asci_impadd_cpi.dta
keep if _merge==3
drop _merge

* save dat/final_asci_raw_variables.dta, replace  
* use dat/final_asci_raw_variables.dta, clear

********************************************************************************
*********** adjusting for inflation and calculating indicators *****************
********************************************************************************

*** adjusting all outputs with producer indices
gen outputtest = SE131-(SE135+SE206+SE256)
sum outputtest  // slight rounding error but accurate

gen croptest = (SE140+SE145+SE150+SE155+SE160+SE165+SE170+SE175+SE185+SE195+SE200)-SE135
sum croptest  // accurate without energy crops. why are they not included in crop output?

gen animaltest = (SE216+SE220+SE225+SE230+SE235+SE240+SE245+SE251)-SE206
sum animaltest  // all within +/- 0.25 of 0 (rounding errors)

drop *test

gen SE140ppi = (SE140/cereals)*100
gen SE150ppi = (SE150/potatoesincludingseedpotatoes)*100
gen SE155ppi = (SE155/sugarbeet)*100
gen SE160ppi = (SE160/rape)*100  
gen SE165ppi = (SE165/industrialcrops)*100
gen SE170ppi = (SE170/((vegetables+plantsandflowers)/2))*100 // SE170 is veg and flower, so averaging the two
gen SE175ppi = (SE175/fruit)*100

foreach var of varlist SE145 SE185 SE195 SE200 {
gen `var'ppi = (`var'/cropoutput)*100
}  // using aggregate crop output ppi for all outputs without a defined ppi value

gen SE216ppi = (SE216/milk)*100
gen SE220ppi = (SE220/cattle)*100
gen SE225ppi = (SE225/pigs)*100
gen SE230ppi = (SE230/sheepandgoats)*100
gen SE235ppi = (SE235/chickens)*100
gen SE240ppi = (SE240/eggs)*100
gen SE245ppi = (SE245/milk)*100 // ppi doesn't have another category for ewe/goat milk
gen SE251ppi = (SE251/animaloutput)*100 

* aggregate output values with ppi adjustment
gen SE135ppi = SE140ppi+SE145ppi+SE150ppi+SE155ppi+SE160ppi+SE165ppi+SE170ppi+SE175ppi+SE185ppi+SE195ppi+SE200ppi
gen SE206ppi = SE216ppi+SE220ppi+SE225ppi+SE230ppi+SE235ppi+SE240ppi+SE245ppi+SE251ppi
gen SE131ppi = SE135ppi+SE206ppi+((SE256/agriculturaloutputtotal)*100) 
cor SE131ppi SE131
* scatter SE131ppi SE131 

*** adjusting data on expenses, asset values and wages paid with consumer price index data
foreach var of varlist F86 G95CV SE275 SE350 SE360 SE370 SE380 SE415 SE420 SE450 SE455 SE460 SE485 SE501 q*  medwage_n3 {
gen `var'cpi = (`var'/cpi)*100
}


* GENERATE MEANS ACROSS YEARS FOR VARIABLES USED IN INDICATOR SPECIFICATION
foreach var of varlist F86cpi SE010 SE030 SE025 SE015 SE350cpi SE370cpi SE020 SE380cpi G95CVcpi SE485cpi SE501cpi SE415cpi SE420cpi {
bysort idn: egen may`var' = mean(`var')    // farm specific Mean Across Years of `var'
}

lab var maySE415cpi "maySE415cpi: mean across years of cpi deflated farm specific value added"

sort idn YEAR
by idn: egen yrseq =seq()  // numbering records per farm (needed for using only one record per farm when taking means across farms)

//  AVERAGE LABOR REMUNERATION VARIABLE
// generate median of agr wage variable (pppepawu) from our FADN data (on national or Fed State level) as an alternative to using Test Farm Results published on Thünen Website.
gen pppepawu = (maySE420cpi + maySE370cpi)/maySE010 if yrseq==1
    egen pppepawu_p10  = pctile(pppepawu) , p(10)
    egen pppepawu_p25  = pctile(pppepawu) , p(25)
    egen pppepawu_p50  = pctile(pppepawu) , p(50)   // by YEAR:               median of [(profit + personel expenses) / AWU], i.e. of avg labor remuneration on the farm
bysort A1: egen pppepawu_p50n = pctile(pppepawu) , p(50)   // BY YEAR and fed state: median of [(profit + personel expenses) / AWU], i.e. of avg labor remuneration on the farm
    egen pppepawu_mean   = mean(pppepawu) 
    egen pppepawu_p75  = pctile(pppepawu) , p(75)
    egen pppepawu_p90  = pctile(pppepawu) , p(90)
format pppepawu* %8.0f


// display agric wage data on national and federal state level 
*qui log on
di "Number of farms in Sample by Federal State (Nuts1) and Median of (means of cpi-deflated values of)" _n ///
   "profit plus personnel expenses per AWU [pppepawu = (SE420 + SE370)/SE010] by Federal State"
table A1 if yrseq==1, c(freq p50 pppepawu) row format(%9.0fc)
*qui log off


save dat/tmp_raw_vars_w_defl.dta, replace  // temporary: final_asci_raw_variables.dta plus deflated versions of some monetary vars


*** PROFITABILITY INDICATOR
gen profit = SE420cpi-(pppepawu_p50n*SE015)  // changed to include regional differences ("cpi" removed from varname because it is a mean across years)
lab var profit "profit: SE420cpi-(pppepawu_p50n*SE015)"
*** SOLVENCY
gen solvency = SE485/SE436  // debt-asset ratio
*replace solvency = 1 if solvency >= 1  // correcting for extreme values   THIS GROUPING MAY BE APPROPRIATE AT LATER STAGE (TO CONTROL MIN-MAX NORMALIZATION AND HENCE WEIGHTING) BUT NOT YET WHILE COMPILING RAW INDICATORS
lab var solvency "solvency: Debt-asset ratio (SE485/SE436)"

* DIVERSIFICATION IN TWO STEPS AND ONE PRECEDING DATA CHECKING STEP

* as the list of products will be used several times I define a macro for it which then can be called whereever needed:
local products SE140 SE145 SE146 SE150 SE155 SE160 SE165 SE170 SE175 SE185 SE195 SE200 SE216 SE220 SE225 SE230 SE235 SE240 SE245 SE251 SE256  // 211125: energy crops (SE146) and other output (SE256) added
//  comment: list of products included in output:
//  SE140=cereals SE145=protein crops SE146=engergy crops SE150=potatoes SE155=sugar beet SE160=oil seed crops SE165=industrial crops SE170=vegs&flowers SE175=fruit SE185=wine SE195=fodder SE200=o.crop output
//  SE216=cows milk SE220=beef SE225=pork SE230=sheep&goat SE235=poultry SE240=eggs SE245=Ewe's&goat's milk SE251=o.lvst prd SE256=o.output

* step 0: check consistency of output figures
*qui log on
di "ASSESSMENT OF THE ECONOMIC DIVERSITY INDICATOR" _n ///
   "Diversity dummy indicates farms with any of the following 19 activities creating >66% of value of output"
describe `products'
*qui log off

egen SE131_s = rowtotal(`products')   // self-computed total output aggregated accross all categories (including energy crops and other output)

* economic diversity as a continuous variable 
local products_p =""
foreach vvv in `products' {
	qui gen `vvv'_p = `vvv'/SE131_s  // share of each product in total output; using the SE131_s should eliminate outliers since we are no longer using the reported SE131
	local products_p  `products_p'  `vvv'_p  // generate string with varnames with suffix _p
}

egen e_diverse = rowmax(`products_p')     // share in total output of the product with the largest share
lab var e_diverse "Specialization: maximum share of a single product in total output"
recode e_diverse   (min / 0 = 1 "<=0%")      (0 / 1 = 2  "0-100%") (1 / 1.1 =3 "100-110%") (1.1/ 2 =4 "110-200%") (2/ max =5 ">200%"),gen(e_diverse_d)
recode e_diverse (min / .33 = 1 "<=33%") (.33 / .66 = 2  "33-66%") (.66 / 1 =3 "66-100%")  (1/ max =4 ">100%"),gen(e_diverse_cl)
label var e_diverse_d "Specialization (maximum share of a single product in total output), grouped"
label var e_diverse_cl "e_diverse-class (=Specialization=maximum share of a single product in total output), grouped"

di _n "Specialization (=reciprocal of economic diversification)" _n
tab e_diverse_d , missing
tab e_diverse_cl 
sum e_diverse, de

* PESTICIDE USE 
gen pesticide = SE300/SE025
lab var pesticide "pestic exp (SE300/SE025 [€/ha])"

*********** EMISSIONS. references to tables and equations are from ipcc guidelines
* n2o manure management: direct emissions using equation 10.25 with table 10.21 for emission factors 
* Germany specific N excretion rates from https://ec.europa.eu/eurostat/documents/2393397/8259002/LiveDate_2014_Task1.pdf/e1ac8f30-3c76-4a61-b607-de99f98fc7cd 
* Assumptions: unknown factor for fraction of manure in a management system so assume 100%; unknown type of system used on farm, so averaging emission factors for all systems
* animal weights derived from state averages from https://www.thuenen.de/media/publikationen/landbauforschung-sonderhefte/lbf_sh324.pdf
gen nex_cow = 0.48*(587/1000)*365
gen nex_cattle = 0.33*(623.57/1000)*365
gen nex_pigs = 0.465*(118.03/1000)*365
gen nex_sg = 1.065*(80/1000)*365

gen mm_n2o_cow = SE085*nex_cow*0.013737*(44/28)
gen mm_n2o_cattle = SE090*nex_cattle*0.013737*(44/28)
gen mm_n2o_pigs = SE100*nex_pigs*0.013737*(44/28)
gen mm_n2o_sg = SE095*nex_sg*0.013737*(44/28)
gen mm_n2o = (mm_n2o_cow+mm_n2o_cattle+mm_n2o_pigs+mm_n2o_sg)*298 // with c02 multiplier
lab var mm_n2o "n2o manure management livestock"

drop mm_n2o_*
summarize mm_n2o

* ch4 manure management: determined by equation 10.22 and table 10.14 using the average annual temp of 10C (climate-data.org reports an average of 10.2 for Germany)
* // IPCC gives a value of 6 for market swine and 9 for breeding swine. Type is unknown so using average of 7.5
gen mm_ch4_cow = (21*SE085)/10^6
gen mm_ch4_cattle = (1*SE090)/10^6
gen mm_ch4_pigs = (7.5*SE100)/10^6 
gen mm_ch4 = (mm_ch4_cow+mm_ch4_cattle+mm_ch4_pigs)*25 // w/multiplier
lab var mm_ch4 "lvst ch4 manure management" 
drop mm_ch4_*
summarize mm_ch4

* ch4 enteric fermentation
gen enteric_cow = (117*SE085)/10^6
gen enteric_cattle = (57*SE090)/10^6
gen enteric_sg = (6.5*SE095)/10^6
gen enteric_pigs = (1.5*SE100)/10^6
gen enteric = (enteric_cow+enteric_cattle+enteric_sg+enteric_pigs)*25 // w/multiplier
lab var enteric "lvst enteric ch4 emiss"
drop enteric_*
summarize enteric

* n2o from fertilizers 
* fertilizers = the sum of crops (in ha) multiplied by the application N(kg)/ha. Must estimate weight from cost and nitrogen content from averages
gen n_fert = (SE295/786)*0.46
gen n2o_fert = (n_fert*0.0125*(44/28))*298  // w/multiplier
lab var n2o_fert "n2o from fertilizers"
sum n2o_fert

* crop residue 
* fresh weight yield data (tonnes/ha) are scarce so using numbers from Eurostat for Germany. These do vary by year but most years are missing so choosing the value closest to the middle of the observation period.  
* cereals 6.69 (2010),
* pulses and protein crops for "other field crops" 2.5 (2011)
* a bulk of energy crop production in Germany is maize, so using that for energy crop land: 9.09 (2010)
* no data for vegetable and flower indicator so omitting
gen cereal_cr = SE035*(((6.69/1000)*1.09+0.88)*(0.006+0.22*0.009))
gen fc_cr = SE041*(((2.5/1000)*1.13+0.85)*(0.008+0.19*0.008))
gen energy_cr = SE042*(((9.09/1000)*1.03+0.61)*(0.006+0.22*0.007))
gen residue = (cereal_cr+fc_cr+energy_cr)*298
drop cereal_cr fc_cr energy_cr
count if residue==. // no missing values
lab var residue "crop residue from cereals, energy crops, and field crops"

* Atmospheric deposition. 
gen f_prp_cow = SE085*nex_cow
gen f_prp_cattle = SE090*nex_cattle
gen f_prp_pigs = SE100*nex_pigs
gen f_prp = f_prp_cow+f_prp_cattle+f_prp_pigs
gen atmospheric = ((((n_fert*0.1)+(f_prp*0.2))*0.01))*298
lab var atmospheric "atmospheric deposition from fertilizers and livestock"
drop nex_* f_prp_*
sum atmospheric

* leaching/runoff // omitting f_som, add cr
gen leaching = ((n2o_fert+f_prp)*0.3*0.0075)*298
lab var leaching "n2o from leaching/runoff"
sum leaching

* CO2 from energy. data sources for value inputs: 
* gas price data from https://www.statista.com/statistics/598020/unleaded-gasoline-prices-germany/ 
* diesel price data from https://www.statista.com/statistics/603701/diesel-fuel-prices-germany/
* heat fuel price data from https://www.statista.com/statistics/597546/heating-oil-price-germany/
* energy data from http://w.astro.berkeley.edu/~wright/fuel_energy.html
gen motor_co2 = (F62/gasoline)*(34.2*10^-5)*(18.9/10^6) // estimates liters of fuel from expenditure in fadn and converts to TJ/liter
lab var motor_co2 "carbon emissions from motor fuels"
sum motor_co2

* CO2 from heating fuels. Since most heating in Germany use natural gas or oil, the values are averaged: 
* for calorified values: (37.3 MJ/liter for oil vs 39.0 MJ/l for gas = 38.15 MJ/l)
* for default IPCC values (21.1 and 17.5 = 19.3)
*gen heating_co2 = (F80/heat)*(38.15*10^5)*(19.3/10^6)
*lab var heating_co2 "carbon emissions from heating fuels"
*sum heating_co2
*** still needs to be fixed. The heat variable exists in the merged data set but doesn't show up here

* carbon stock // currently using tier 1 estimation methods from IPCC and using the gain loss method
* note: only measured for forest and other permanent crops, as the IPCC assumes that annual crops have an insignificant impact on carbon stock
gen forest_stock = SE075*4*0.5
gen perm_stock = (SE054*2.1)-(SE054*63)     // ????????????????? check formulae for forest and perma inconsistent??? BB: still need to verify but this looks correct.
gen carbon_stock = forest_stock+perm_stock
lab var forest_stock "C-stock forest"
lab var perm_stock   "C-stock permacult"
lab var carbon_stock "C-stock total"

gen ghg_emissions_sum = mm_n2o+mm_ch4+enteric+n2o_fert+atmospheric+leaching+motor_co2+carbon_stock+residue // to do: fix and add heating_co2, check carbon stock
*gen ghg_emissions = ghg_emissions_sum/SE131ppi  // for averages
gen ghg_emissions = ghg_emissions_sum/SE410  
sum ghg_emissions, de  // there are quite a few extreme values but they do seem plausible
tabstat ghg_emissions, by(TF14) stat(mean sd min max)
lab var ghg_emissions "carbon, nitrous, and methane emissions per euro of output"
drop mm_* enteric *_fert residue f_prp atmospheric leaching motor_co2 *_stock ghg_emissions_sum

/*** ECOLOGICAL VALUE OF LAND
* checking data
browse id year *_h SE025 SE030
 notes on land data from tests below: 
	1) permanent crops is a sum of orchard, other perm, forage crops, fallows, set aside, out of production, woodland (i.e. do not include perm crops in aggregations)
 	2) set aside and out of production are often the same. calculating to remove any double counting and merge them into 1 variable
 	3) the difference between set aside and out of production appears to be equal to fallow
 	4) land used for energy crops and woodland not included in total uaa: the latter makes sense but why the former?
*/
gen out_of_production = SE074-SE073
sum out_of_production
* sum produced no negative numbers so it is assumed this new variable will distinguish between set aside and out of production
drop SE074
gen fallow_test = SE072-out_of_production
sum fallow_test // test to see if fallow and out of production are duplicates. produced a min of -.0000305 and a max of .0000153; assumed to be rounding errors so out of production will be dropped to avoid double counting
drop out_of_production
drop fallow_test
gen total_land = SE035+SE041+SE042+SE046+SE050+SE055+SE065+SE071+SE072+SE073+SE075
gen land_test = total_land-SE025
sum land_test 
gsort -land_test // checking what is not listed in total UAA
gen test2 = (SE042+SE075)-land_test // energy crops and woods not listed in total uaa. test produced a min of -.0100067 and a max of .0100001, assumed to be rounding difference
drop land_test
drop test2

** calculating diversity using health food diversity index and berry index
* as the list of crops will be used several times I define a macro for it which then can be called repededly:
global croplist SE035 SE041   SE042  SE046  SE050 SE055 SE065  SE071 SE072  SE073 SE075
**              cer   oFieldC energy vegFlo Viny  Orch  oPermC Forag fallow SetAs Wood
global croplistlength : word count $croplist

* NEW METHOD BASED ON ECOLOGICAL QUALITY (%)
* input values
gen land_inprod = SE025-(SE072+SE073) // land used in production only

gen grazing = .    // percentage of land that is for forage crops
replace grazing = 0 if SE071/SE025 < 0.66
replace grazing = 1 if SE071/SE025 >= 0.66

gen luha = SE080/land_inprod  // total livestock units per ha

gen input_sum = (SE295+SE300+SE310+SE315)/land_inprod  // expenditure per ha on fertilizers, pesticides, and feedstuffs
gen inputs = .
replace inputs = 0 if input_sum > 250
replace inputs = 1 if input_sum <= 250 & input_sum > 80
replace inputs = 2 if input_sum <= 80

gen organic = .   // recategorizing organic: partial or transitioning included with organic
replace organic = 0 if A32 == 1
replace organic = 1 if A32 == 2 | A32 == 3

gen irrigation = .  // dummy variable for if farm has irrigation
replace irrigation = 0 if A40 == 0
replace irrigation = 1 if A40 > 0

* creating ecological value of used land
gen evul = .
replace evul = 0.05 if (organic == 0 & irrigation == 1) 
replace evul = 0.05 if (organic == 0 & irrigation == 0 & inputs == 0)
replace evul = 0.1 if organic == 1 & inputs == 1
replace evul = 0.15 if grazing == 0 & inputs != 0
replace evul = 0.15 if organic == 1 & (irrigation ==1 | inputs == 0)
replace evul = 0.2 if grazing == 1 & (luha > 2 | inputs == 0)
replace evul = 0.2 if grazing == 1 & luha < 2 & inputs != 0
replace evul = 0.2 if organic == 1 & inputs == 1
replace evul = 0.25 if organic == 0 & inputs == 2
replace evul = 0.325 if grazing == 0 & luha < 1 & inputs == 2
replace evul = 0.35 if organic == 1 & inputs == 2
replace evul = 0.4 if grazing == 1 & luha < 1 & inputs < 80
replace evul = 1 if grazing == 1 & luha < 0.3
tab evul

* creating total ecological quality of land on the farm: evul + land not being used in production
gen tot_land = SE025+SE075  // total land on farm
gen noprod = SE072+SE073+SE075  // land with 100% ecological quality (i.e. not in production)
gen land_quality = ((land_inprod*evul)+noprod)/tot_land
lab var land_quality "Ecological value of land"
drop land_inprod grazing luha input_sum inputs organic irrigation evul tot_land noprod

/*  OLD METHOD
* binning the land types: wooded still is SE075
gen noprod_h = SE073+SE072    // check whether missing vals are produced. egen rowsum() is safer
gen permanent_h = SE065+SE050+SE055
gen field_h = SE035+SE071+SE042+SE041+SE046

foreach var of varlist SE075 noprod_h permanent_h field_h {
gen s_`var' = `var'/total_land
gen s2_`var' = s_`var'^2
}

* The weights below are placeholders and will be replaced after the expert survey
gen df_woods = s_SE075*0.4
gen df_noprod = s_noprod_h*0.3
gen df_permanent = s_permanent_h*0.2
gen df_field = s_field_h*0.1

gen df_sum = df_woods+df_noprod+df_permanent+df_field
gen s2_sum = s2_SE075+s2_noprod_h+s2_permanent_h+s2_field_h
gen diversity_calc = (1-s2_sum)*df_sum
gen land_diversity = diversity_calc // for continuous variable
lab var land_diversity "land uses carried out on farm among the $croplistlength options [share]" 
drop total_land noprod_h permanent_h field_h diversity_calc s_* s2_* df_*
*/

*** MEDIAN WAGE CALCULATIONS

gen p_wage = SE370cpi/SE021    // consider outlier cleaning. many values are below 2€/hour
lab var p_wage    "p_wage=wages paid(SE370cpi) / PaidLabInput(SE021) [2015-€/hr]"
sum p_wage, de  // checking the values

gen med_region_n3 = medwage_n3cpi/1920 // annual wage / avg # of working hrs per year
lab var med_region_n3 "med_region_n3=NUTS3 all-sector-median wage [2015-€/hr]"

gen paid_wage = p_wage/med_region_n3 
*replace paid_wage = 0 if paid_wage == .
lab var paid_wage "wage_ratio=p_wage(n3-median FarmWagesPaid) / med_region_n3(n3 AllSectorMedianWage)"
*qui log on
di "`=char(12)' Distrib of paid_wage: ratio of farm wage and median all-sector-wage (both nuts-3 medians):"
codebook paid_wage
*qui log off  
drop p_wage med_region_n3 

* "provision of employment" = employment created + contracts

gen prov_employ = (maySE370cpi+maySE350cpi)/SE131ppi
sum prov_employ
lab var prov_employ `"Provision of employment and contract work to t output [€/€]"'

* MULTI-FACTOR PRODUCTIVITY

* I.a) LAND USE COST COMPUTATION: 
gen lruv = mayF86cpi / maySE030           // farm specifc raw Land Rental Unit Value 
*** compute mean of (plausible) land rent values by each combination of TF14 and A1
gen lruv1 = lruv if yrseq == 1    //  contains only one nonmissing lruv per farm (avoids unequal weighting farms w different # of participation years differently according to their #)
local lruvUpLimspec 4000 // for plausible land rental price computation: upper Euro-per-ha-and-year limit for inclusion among specialized horticulture, wine, fruits
local lruvUpLimrest 2000 // for plausible land rental price computation: upper Euro-per-ha-and-year limit for inclusion among all other farm types
replace lruv1  = . if  (( inlist(TF14,20,35,36) & lruv1>=`lruvUpLimspec' ) | (!inlist(TF14,20,35,36) & lruv1>=`lruvUpLimrest')) // set farm specific lruv to missinhg where implausible
bysort TF14: egen lruvTF14 = mean(lruv1)        // mean of (plausible) land rent values by each combination of TF14
bysort TF14 A1: egen lruvTF14A1 = mean(lruv1)        // mean of (plausible) land rent values by each combination of TF14 and A1
replace lruvTF14A1 = lruvTF14 if inlist(lruvTF14A1,.,0)       // use TF14 avg if avg for specific A1 is missing
* END OF: compute mean of (plausible) land rent values by each combination of TF14 and A1

local lruvLoLimspec 500 // to determine for which farms to impute land rent unit value: lower Euro-per-ha-and-year limit for inclusion among specialized horticulture, wine, fruits
local lruvLoLimrest 200 // to determine for which farms to impute land rent unit value: lower Euro-per-ha-and-year limit for inclusion among all other farm types
replace lruv = lruvTF14A1 if  ( inlist(TF14,20,35,36) & ((lruv<`lruvLoLimspec' )|(lruv>`lruvUpLimspec' ))) | (!inlist(TF14,20,35,36) & ((lruv<`lruvLoLimrest' )|(lruv>`lruvUpLimrest'))) // replace implausible farm specific lruv by means per A1 and TF14
gen lndcost = mayF86 + (maySE025-maySE030) * lruv  // land use costs 
* END OF: COMPUTE LAND USE COSTS

* I.b) LABOR COST 
gen pluv = maySE370cpi / maySE020           // farm specifc raw paid labor unit value
*** compute mean of (plausible) paid labor wage by A1
gen pluv1 = pluv if yrseq == 1    //  contains only one nonmissing pluv per farm (avoids unequal weighting farms w different # of participation years differently according to their #)
local pluvLoLim 6000 // for plausible paid labor wage computation: lower Euro-per-AWU-and-year limit for inclusion
local pluvUpLim 50000 // for plausible paid labor wage computation: upper Euro-per-AWU-and-year limit for inclusion
gen lruv1_roh  =  pluv1 
replace pluv1  = . if  ( pluv1<`pluvLoLim' ) | (pluv1>`pluvUpLim') // set farm specific pluv to missinhg where implausible
bysort A1: egen pluvA1 = mean(pluv1)        // mean of (plausible) paid labor wage by federal state (A1)
* END OF: compute mean of (plausible) paid labor wage values by A1
replace pluv = pluvA1 if ( pluv1<`pluvLoLim' ) | (pluv1>`pluvUpLim')  // replace implausible farm specific pluv by means per A1
lab var pluv "pluv: Paid labor Unit Value (quotient of means across years of SE370cpi and SE020, w outliers replaced by mean per A1)"
gen labcost = maySE370cpi + maySE015 * pluv  // labor costs 

* I.c) CAPITAL COST COMPUTATION (based on 8 alternative formulae): 
gen air =  .04  // assumed interest rate  4% (LH ...)
gen capcost = maySE380cpi + max((maySE501cpi-mayG95CVcpi),0)*air

* II. MULTI FACTOR PRODUCTIVITY
  egen totcost = rowtotal(lndcost labcost capcost)
  gen productivity  = maySE415cpi/totcost   // multi factor productivity computed as maySE415/totcost`i'
    lab var productivity "productivity=maySE415cpi/totcost [€/€])"
drop lruv* pluv* *cost air
summarize productivity if yrseq==1, detail    
   

*** * I want a constant value for the profit thresholds when the data are collapsed
*** * This probably isn't the best way to do it but it seems to work well:
*** foreach var of varlist pppepawu_*cpi {
*** egen `var'mean = mean(`var')
*** }

save dat/110-asci_complete_raw_indicators.dta, replace  // for all calculated indicators with raw variables remaining 

*qui log on
describe
codebook profit solvency e_diverse productivity pesticide ghg_emissions land_quality prov_employ paid_wage 
*qui log off
 

end // end program logfi

logfi  // call program logfi (this command only works if it is not in the last line of the do file, i.e. at least one cr/lf character must follow!)
